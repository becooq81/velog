<blockquote>
<p>이 문서는 &lt;객체지향의 사실과 오해 (조영호 지음)&gt;을 읽으며 작성한 개인 노트입니다.</p>
</blockquote>
<p>객체지향 설계 안에 존재하는 세 가지 상호 연관된 관점</p>
<ol>
<li><p><strong>개념 관점(Conceptual Perspective)</strong>: 도메인 내 존재하는 개념과 개념들 간 관계를 표현한다. 사용자가 도메인을 바라보는 관점을 반영한다.</p>
</li>
<li><p><strong>명세 관점(Specification Perspective)</strong>: 사용자의 영역인 도메인을 벗어나, 개발자의 영역인 소프트웨어에 집중한다. 객체가 협력을 위해 무엇을 할 수 있는가에 초점을 맞춰 인터페이스를 설계하는 관점이다. 구현과는 분리된 관점임이 핵심이다.</p>
</li>
<li><p><strong>구현 관점(Implementation Perspective)</strong>: 실제 작업을 수행하는 코드와 연관되어 있다. 객체가 책임을 어떻게 수행할 것인가에 초점을 맞춰 인터페이스를 구현하는 데 필요한 속성과 메서드를 클래스에 추가한다.</p>
</li>
</ol>
<p>위 세 가지 관점은 설계 및 개발의 순서가 아닌, 하나의 클래스를 바라볼 수 있는 여러 관점일 뿐이다. </p>
<ul>
<li>클래스가 은유하는 개념 =&gt; 도메인 관점</li>
<li>클래스의 공용 인터페이스 =&gt; 명세 관점</li>
<li>클래스의 속성과 메서드 =&gt; 구현 관점</li>
</ul>
<p>즉, 클래스는 세 가지 관점을 모두 수용할 수 있도록 개념, 인터페이스, 구현을 함께 드러내야 한다. </p>
<h1 id="인터페이스와-구현을-분리하라">인터페이스와 구현을 분리하라</h1>
<p>명세 관점은 클래스의 안정적인 측면을 드러내고, 구현 관점은 클래스의 불안정한 측면을 드러내야 한다.</p>
<p>인터페이스가 구현 세부 사항을 노출하기 시작하면 아주 작은 변동에도 전체 협력이 요동치는 취약한 설계를 얻을 수 밖에 없다. </p>
<hr />
<p>추상화는 도메인의 복잡성을 단순화하고 직관적인 모델을 만드는 수단이다. </p>
<p>추상화 기법은 다음과 같다</p>
<ul>
<li><strong>분류와 인스턴스화</strong>: <ul>
<li>분류: 객체의 세부 사항을 숨기고, 인스턴스 간 공유되는 공통 특성을 기반으로 범주를 형성한다</li>
<li>인스턴스화는 분류의 역으로, 범주로부터 객체를 생성한다</li>
<li>(예) <code>자동차</code>라는 분류를 <code>자동차 A</code>, <code>자동차 B</code>, <code>자동차 C</code>로 인스턴스화한다</li>
<li><code>자동차</code>는<code>자동차 A</code>, <code>자동차 B</code>, <code>자동차 C</code>의 부모 타입이다.</li>
</ul>
</li>
<li><strong>일반화와 특수화</strong>:<ul>
<li>일반화는 범주 간 차이를 숨기고, 범주 간 공유되는 공통 특성을 강조한다</li>
<li>그 역이 특수화</li>
<li>(예) 세단과 미니벤은 자동차로 일반화할 수 있다. 운송 수단은 자동차와 자전거로 특수화할 수 있다.</li>
</ul>
</li>
<li><strong>집합과 분해</strong>:<ul>
<li>집합은 부분과 관련된 세부 사항을 숨기고, 부분을 사용해서 전체를 형성한다</li>
<li>분해는 전체를 부분으로 분리한다</li>
<li>(예) 자동차는 차체, 엔진, 섀시의 집합이다. =&gt; 자동차는 차체, 엔진, 섀시를 필드로 갖는다</li>
</ul>
</li>
</ul>
<p>분류: </p>
<ul>
<li><strong>단일 분류(Single Classification)</strong>: 한 객체가 한 시점에 하나의 타입에만 속한다</li>
<li><strong>다중 분류(Multiple Classification)</strong>: 한 객체가 한 시점에 여러 타입에 속한다 <ul>
<li>(예) 어떤 컴퓨터는 데스크톱 컴퓨터인 동시에 사무용 컴퓨터다</li>
</ul>
</li>
<li><strong>동적 분류(Dynamic Classification)</strong>: 객체가 한 집합에서 다른 집합의 원소로 자신이 속하는 타입을 변경할 수 있는 경우 </li>
<li><strong>정적 분류(Static Classification)</strong>: 객체가 자신의 타입을 변경할 수 없는 경우</li>
</ul>
<p>슈퍼타입과 서브타입</p>
<ul>
<li><strong>슈퍼타입(Supertype)</strong>: 어떤 타입이 다른 타입보다 일반적이다</li>
<li><strong>서브타입(Subtype)</strong>: 어떤 타입이 다른 타입보다 더 특수하다</li>
<li><code>서브타입</code> is a <code>슈퍼타입</code>: 서브타입은 슈퍼타입의 부분집합이다</li>
</ul>
<p>상속은 다음 두 가지 용도로 쓰인다</p>
<ul>
<li><strong>서브타이핑(Subtyping)</strong>: 서브클래스가 슈퍼클래스를 대체할 수 있는 경우<ul>
<li>목적: 설계의 유연성</li>
<li>인터페이스 상속</li>
</ul>
</li>
<li><strong>서브클래싱(Subclassing)</strong>: 서브클래스가 슈퍼클래스를 대체할 수 없는 경우<ul>
<li>목적: 코드의 중복 제거, 재사용</li>
<li>구현 상속</li>
</ul>
</li>
</ul>
<p>위임(delegation): </p>
<ul>
<li>어떤 객체의 클래스가 수신된 메시지를 이해할 수 없다면 메시지를 클래스의 부모 클래스로 위임한다</li>
<li>부모 클래스도 메시지를 이해할 수 없다면 자신의 부모 클래스로 다시 메시지를 위임한다</li>
</ul>
<p><strong>패키지</strong> 또는 <strong>모듈</strong>: 관련된 클래스 집합을 하나의 논리적인 단위로 묶는 구성 요소 </p>
<ul>
<li>클래스의 집합으로 캡슐화하여 전체적인 복잡도를 낮춘다 </li>
</ul>