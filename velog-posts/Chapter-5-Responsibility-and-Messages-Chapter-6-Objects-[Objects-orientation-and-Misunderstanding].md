<blockquote>
<p>이 문서는 &lt;객체지향의 사실과 오해 (조영호 지음)&gt;을 읽으며 작성한 개인 노트입니다.</p>
</blockquote>
<p>자율성은 자신 스스로의 원칙에 따라 어떤 일을 하거나 자신을 통제해서 절제하는 특성이다. 자신의 의지와 관계없이 정해진 원칙에 따라 움직이는 타율성과는 반대되는 성질이다. </p>
<p>객체지향 공동체의 기본단위는 자율적인 객체이기에 객체는 스스로의 의지와 판단에 따라 자신의 책임을 수행한다. 물론 다른 객체로부터 요청을 수신하여 책임을 수행한다. </p>
<p>적절한 책임이 자율적인 객체를 낳고, 자율적인 객체들이 모여 유연하고 단순한 협력을 낳는다. </p>
<blockquote>
<p>협력을 정의하고, 이에 필요한 책임을 정의하여 객체를 설계하라는 2장의 내용과 유사하다.</p>
</blockquote>
<p>책임을 수행해야 하는데 그게 어떻게 자율적이냐? 라는 생각이 들 수 있지만 책임을 다하는 한, 어떻게 책임을 다하는지는 전적으로 객체의 자율성에 달려 있다. 상호작용하는 객체도 그 객체의 내부적인 구현에는 상관하지 않는다. </p>
<p>책임의 추상화가 과해도 적절하지 않다. 책임은 언제나 협력의 의도가 명확해야 한다. 예를 들어 '설명해라' 라는 책임은 무엇을 설명해야 하는지 모호하다. 그러니 '역사를 설명해라' 등 명확한 의도를 표현해줘야 한다. </p>
<h1 id="메시지">메시지</h1>
<p>메시지는 객체 간 소통 수단이다. 전송하는 메시지를 메서드명으로 정의하고, 책임을 다하는데 필요한 추가적인 정보는 인자(argument)으로 전달한다.</p>
<p>메시지를 수신한 객체는 먼저 자신이 해당 메시지를 처리할 수 있는지 확인하고, 메시지를 처리할 수 있다고 판단하면 자신의 책임을 다하기 위해 메서드를 선택한다. 객체는 자율적인 존재니까 메시지는 어떤 메서드를 호출할지를 정의하지는 않는다. 메시지의 내용에 부합하는 한, 어떤 메서드를 호출할 지는 수신하는 객체가 정한다. </p>
<p>수신 객체가 런타임에 어느 메서드를 호출할지 선택하는 것은 객체지향 언어의 특징이다. 반면, 절차적인 언어는 프로시저 호출에 대한 실행 코드를 컴파일 시간에 결정한다. </p>
<h1 id="다형성">다형성</h1>
<p>다형성이란 서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다르게 반응하는 것을 의미한다. 즉, 서로 다른 타입의 객체가 동일한 메시지에 대해 다르게 반응한다. </p>
<p>서로 다른 객체가 다형성을 만족한다는 것은 곧 이 객체들이 같은 책임을 공유한다는 의미다. 메시지 송신자의 관점에서 동일한 역할을 수행하는 다양한 타입의 객체와 협력할 수 있다. 송신자 입장에서는 이 모든 객체들이 같은 역할을 수행하기 때문에 송신자 관점에서는 이 객체들이 대체 가능하다. 이 대체 가능성은 곧 객체의 재사용성과 유연성으로 이어진다. </p>
<p>송신자는 수신자의 상세한 타입을 모르더라도, 역할만을 기반으로 메시지를 전송할 수 있다. 수신자의 캡슐화를 의미한다. 결과적으로 송신자의 역할에는 영향을 주지 않고도 새로운 수신자를 추가하는 등 작업을 수행할 수 있다.</p>
<p>이를 객체지향에서는 송신자와 수신자 간 객체 타입에 대한 결합도를 낮춘다고 이야기 한다. 다형성으로 메시지를 이해할 수 있는 어떤 객체와도 협력할 수 있는 유연하고 확장 가능한 구조를 만든다. </p>
<h1 id="유연하고-확장-가능하고-재사용성이-높은-협력">유연하고 확장 가능하고 재사용성이 높은 협력</h1>
<p>송신자는 수신자가 이 메시지를 이해할 수 있다는 사실만 알고 있더라도 상호 협력이 가능하다. 그래서 협력이 유연해지고, 확장이 가능해지고, 재사용성이 높아진다. </p>
<p>위 조건 한 가지만 만족하면 수신자가 추가되든, 메서드 내부 구현이 변경되든 송신자에 영향을 끼치지 않는다. </p>
<h1 id="중요한-건-클래스가-아니다">중요한 건 클래스가 아니다.</h1>
<p>클래스는 단지 동적인 객체들의 특성과 행위를 담기 위해 사용할 수 있는 추상화 도구(틀)일 뿐이다. </p>
<h1 id="인터페이스">인터페이스</h1>
<p>인터페이스는 어떤 두 사물이 마주치는 경계에서 서로 작용할 수 있게 이어주는 약속의 집합이다. </p>
<ol>
<li>인터페이스의 사용법을 익히면 내부 구조를 몰라도 상호작용할 수 있다.</li>
<li>인터페이스 내부의 변경사항은 인터페이스의 사용자에 영향을 끼치지 않는다.</li>
<li>사용자가 달라져도 인터페이스에 영향을 끼치지 않는다.</li>
</ol>
<p>인터페이스는 곧 객체가 수신할 수 있는 메시지의 목록으로 구성된다. 객체의 자율성을 보존하기 위해 인터페이스는 더 추상적으로, 최소한으로 설계해야 한다.</p>
<p>인터페이스의 메시지를 필요 이상으로 상세하게 정의하면 객체는 그 상세함을 따라 구현해야 하니 구현의 자율성을 저해한다. 또한, 인터페이스를 최소한으로 정의하여 외부에 미치는 영향을 최소화하는 데 핵심적이다.</p>
<h1 id="정리">정리</h1>
<ol>
<li><p>자율적인 책임은 협력을 단순하게 만든다. </p>
</li>
<li><p>자율적인 책임은 인터페이스와 구현을 명확하게 분리한다. 즉, 구현이 캡슐화되고, 구현의 변경은 외부에 영향을 미치지 않는다. </p>
</li>
<li><p>자율적인 책임은 협력의 대상에 대한 유연성을 제공한다. 책임을 수행할 수 있는 어느 객체든 그 역할을 맡을 수 있다. </p>
</li>
<li><p>객체가 수행하는 책임들이 자율적일수록 객체의 역할을 이해하기 쉬워진다. 자율적인 책임이 모여 객체의 명확한 역할을 정의하고, 이는 객체의 응집도를 높인다. </p>
</li>
</ol>
<ul>
<li>추상화, 높은 응집도, 낮은 결합도, 캡슐화, 인터페이스와 구현의 분리, 유연성, 재사용성</li>
</ul>
<hr />
<p>요구사항은 항상 변경된다. 이 예측 불가능한 요구사항 변경에 유연하게 대처할 수 있는 안정적인 구조를 제공해야 한다. 객체지향은 자주 변경되지 않는, 안정적인 객체 구조를 바탕으로 기능을 객체 간의 책임으로 분배하여 변경사항에 대비한다.</p>
<p>기능은 사용자의 목표를 만족시키기 위해 책임을 수행하는 시스템의 행위, 구조는 사용자나 이해관계자들이 도메인에 관해 생각하년 개념과 그들 간의 관계로 표현한다. </p>