<h1 id="리모콘-백준1107">리모콘 백준#1107</h1>
<p>골드5</p>
<h2 id="문제">문제</h2>
<ul>
<li>타겟 채널 N이 주어진다 (0 &lt;= N &lt;= 500000)</li>
<li>선택지는 0~9 숫자 또는 + (채널 + 1), - (채널 - 1)</li>
<li>M개의 고장난 채널이 주어진다</li>
<li>시작 채널은 100이다. </li>
</ul>
<p>최소 이동으로 N으로 이동해라</p>
<h2 id="풀이">풀이</h2>
<p><code>ans</code> 변수를 가장 단순한, 100부터 하나씩 올라/내려가는 이동 수로 초기화한 다음 최적화한다. </p>
<pre><code class="language-java">int ans = Math.abs(N - 100);</code></pre>
<p>이제 0부터 넉넉잡아 999999까지 <code>for loop</code>을 돌면서 더 나은 답안을 찾고자 한다. </p>
<pre><code class="language-java">for (int i = 0; i &lt;= 999999; i++) {
    ...
}</code></pre>
<p><code>i</code>의 각 자릿수마다 고장난 버튼인지 확인한다.</p>
<ul>
<li>고장난 버튼이면 성립 불가한 경우의 수기 때문에 넘어간다. </li>
<li>고장난 버튼 없이 마지막 자릿수까지 도달하면 현재 <code>i</code>에서 <code>N</code>까지 도달하는데 필요한 1단위 이동 수와 <code>i</code>를 입력하는데 필요한 이동 수 (<code>values.length</code>)를 기존 <code>ans</code>값과 비교하여 최솟값을 저장한다.</li>
</ul>
<pre><code class="language-java">int ans = Math.abs(N - 100);
for (int i = 0; i &lt;= 999999; i++) {
    char[] values = String.valueOf(i).toCharArray();
    for (int j = 0; j &lt; values.length; j++) {
        if (broken[values[j] - '0']) {
            break;
        } else if (j == values.length - 1) {
            ans = Math.min(ans, Math.abs(i - N) + values.length);
        }
    }
} 
System.out.println(ans);</code></pre>
<h2 id="오답">오답</h2>
<p>고장난 버튼의 수가 0인 경우 숫자가 아예 주어지지 않는다. 이를 고려하여 if문을 이용하여 버퍼드리더를 사용했어야 한다. 이 때문에 <code>NullPoint</code> 에러가 발생했다. </p>
<hr />