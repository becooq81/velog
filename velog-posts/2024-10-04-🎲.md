<h1 id="스카이라인-쉬운거-백준1864">스카이라인 쉬운거 [백준#1864]</h1>
<p>골드4</p>
<p><a href="https://github.com/becooq81/Algorithms/blob/main/Java/%EB%B0%B1%EC%A4%80/Gold/1863.%E2%80%85%EC%8A%A4%EC%B9%B4%EC%9D%B4%EB%9D%BC%EC%9D%B8%E2%80%85%EC%89%AC%EC%9A%B4%EA%B1%B0/%EC%8A%A4%EC%B9%B4%EC%9D%B4%EB%9D%BC%EC%9D%B8%E2%80%85%EC%89%AC%EC%9A%B4%EA%B1%B0.java">스카이라인 쉬운거 JAVA 코드</a></p>
<h2 id="문제-이해">문제 이해</h2>
<p>건물 높이의 윤곽을 보고 건물의 최소 수를 알아내는 문제다. </p>
<p>건물 높이는 윤곽만 보이기 때문에 중복 높이는 같은 건물이라고 볼 수도 있다. 단, 중복 높이 사이에 그 높이보다 낮은 높이의 윤곽이 존재한다면, 두 개의 건물로 나뉜다고 볼 수 있다.</p>
<p>(예시1) 높이가 {5, 7, 5}로 주어지면, 건물의 최소 수는 2다. 5와 5는 같은 건물이라 생각할 수 있고, 높이가 다른 7도 하나의 건물이다.</p>
<p>(예시2) 높이가 {4, 0, 4}로 주어지면, 건물의 최소 수는 2다. 높이 4가 두 개 있지만, 중간에 0이 있기 때문에 중복을 제거하지 않는다.</p>
<p>그래서 건물 높이의 순서가 중요하다. 현재 높이보다 다음 높이가 더 낮으면, 이 다음 높이보다 높은 건물들은 앞으로 순회할 모든 건물들과 분리된 별도의 건물이다. </p>
<h2 id="해결-방안">해결 방안</h2>
<p>스택 자료구조를 활용해서 풀이를 고안했다. </p>
<ol>
<li>현재 스택이 비어있을 경우</li>
</ol>
<p>스택이 비어있으면 비교할 높이가 없기 때문에 단순히 더해주면 된다.</p>
<ol start="2">
<li>현재 스택의 가장 오른쪽 값보다 다음 높이가 더 높을 경우</li>
</ol>
<p>다음 높이가 더 높으면 (예시1)의 경우를 고려하기 위해 일단 스택에 더해준다.</p>
<ol start="3">
<li>현재 스택의 가장 오른쪽 값보다 다음 높이가 더 낮을 경우</li>
</ol>
<p>이 경우는 (예시2)와 같으므로, 다음 높이와 같거나 낮은 높이까지 <code>pop</code>해줘야 한다.</p>
<ol start="4">
<li>현재 스택의 가장 오른쪽 값과 다음 높이가 같을 경우</li>
</ol>
<p>이 때는 중복 높이기 때문에 굳이 더해줄 필요 없다.</p>
<pre><code class="language-java">ArrayDeque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();

int ans = 0;
for (int i = 0; i &lt; N; i++) {
    st = new StringTokenizer(br.readLine());
    int x = Integer.parseInt(st.nextToken());
    int y = Integer.parseInt(st.nextToken());

    while (!stack.isEmpty() &amp;&amp; stack.peekLast() &gt; y) {
        ans++;
        stack.pollLast();
    }
    if (stack.isEmpty() || stack.peekLast() &lt; y) {
        stack.add(y);
    }
}</code></pre>
<p>마지막으로, 순회가 끝난 이후 스택에 남아있는 높이는 0이 아닌 이상 모두 개별 빌딩이다.</p>
<pre><code class="language-java">while (!stack.isEmpty()) {
    if (stack.pollLast() &gt; 0) ans++;
}

System.out.println(ans);</code></pre>
<hr />